<html>
  <head>
    <link rel="stylesheet" href="markdown.css"/>
    <link rel="stylesheet" href="/css/bootstrap.min.css"/>
  </head>
  
  <body>
    <div id="readme" class="announce md" data-path="/">
      <div class="wikistyle content-body markdown-body">
<h1>Prime summation</h1>

(For the mathematically inclined, this resembles the partition problem, except that the components are limited to prime numbers.)
<br/>A prime sieve can generate the pertinent primes, though that isn't the critical part. Although the number of ways to write a number increases exponentially, the tests are fairly small. A "naive" solution that enumerates all ways can pass, despite the exponential running time. The key is to ensure that reordered sums are not recounted. A clean solution is to impose an increasing or decreasing ordering on the summands, and enforce that in your algorithm.
<br/>
<br/>
The C++ solution below finds the summands in order from least to greatest (e.g. 2+3+5=10), in order to prevent duplicates. It uses a naive prime test, but it still manages to pass the time requirement.
<br/>
<a data-toggle="collapse" data-target="#prime-cpp">
  <b>C++</b>
</a>
<div id="prime-cpp" class="collapse">
<pre><code>#include &lt;iostream>

bool isPrime(int n) {
    for (int i = 2; i &lt; n; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return n > 1;
}

int numWays(int n, int minPrime=2) {
    int sum = !n;
    for (int i = minPrime; i &lt;= n; i++) {
        if (isPrime(i)) {
            sum += numWays(n-i, i);
        }
    }
    return sum;
}

int main() {
    int n;
    std::cin >> n;
    std::cout &lt;&lt; numWays(n) &lt;&lt; "\n";
}</code></pre>
</div>

The Java solution below finds the summands in order from greatest to least (e.g. 5+3+2=10). It improves the time significantly by using a seive to precompute the primes.
<br/>
<a data-toggle="collapse" data-target="#prime-java">
  <b>Java</b>
</a>
<div id="prime-java" class="collapse">
<pre><code>import java.util.*;

class Main {
    private static List&lt;Integer> calcPrimes(int maxPrime) {
        boolean[] isNotPrime = new boolean[maxPrime+1];
        for (int i = 2; i &lt;= maxPrime; i++) {
            if (!isNotPrime[i]) {
                for (int j = i * i; j &lt;= maxPrime; j += i) {
                    isNotPrime[j] = true;
                }
            }
        }
        List&lt;Integer> primes = new ArrayList&lt;Integer>();
        for (int i = 2; i &lt;= maxPrime; i++) {
            if (!isNotPrime[i]) {
                primes.add(i);
            }
        }
        return primes;
    }

    private static int numWays(int n, List&lt;Integer> primes, int maxI) {
        int sum = (n == 0) ? 1 : 0;
        for (int i = 0; i &lt;= maxI &amp;&amp; primes.get(i) &lt;= n; i++) {
            sum += numWays(n-primes.get(i), primes, i);
        }
        return sum;
    }

    public static void main(String[] args) {
        int n = new Scanner(System.in).nextInt();
        List&lt;Integer> primes = calcPrimes(n);
        System.out.println(numWays(n, primes, primes.size()-1));
    }
}</code></pre>
</div>

The Python solution below uses an (unnecessarily) clever DP approach that takes only O(n*n/log(n)).
<br/>
<a data-toggle="collapse" data-target="#prime-python">
  <b>Python</b>
</a>
<div id="prime-python" class="collapse">
<pre><code>import sys

def primes(max):
    isprime = [False, False] + [True]*(max-2)
    for p in (p for p, b in enumerate(isprime) if b):
        yield p
        for multiple in xrange(p*p, max, p):
            isprime[multiple] = False
  
x = int(sys.stdin.readline())
ways = [1] + [0]*x
for p in primes(x+1):
    ways = [sum(ways[i::-p]) for i in xrange(x+1)]

print ways[x]</code></pre>
</div>

<h1>Greatest common divisor</h1>

Use the Euclidean algorithm...
<br/>
<a data-toggle="collapse" data-target="#gcd-cpp">
  <b>C++</b>
</a>
<div id="gcd-cpp" class="collapse">
<pre><code>#include &lt;iostream&gt;

int main() {
    int gcd;
    std::cin >> gcd;
    for (int a; std::cin >> a; ) {
        while (a) {
            int t = a;
            a = gcd % a;
            gcd = t;
        }
    }
    std::cout &lt;&lt; gcd &lt;&lt; std::endl;
}</pre></code>
</div>

...or Java's BigInteger.gcd() method...
<br/>
<a data-toggle="collapse" data-target="#gcd-java">
  <b>Java</b>
</a>
<div id="gcd-java" class="collapse">
<pre><code>import java.math.BigInteger;
import java.util.Scanner;

class Main {
    public static void main(String[] args) { 
        Scanner in = new Scanner(System.in);
        BigInteger gcd = new BigInteger(in.next());
        while (in.hasNext()) {
            gcd = gcd.gcd(new BigInteger(in.next()));
        }
        System.out.println(gcd);
    }
}</code></pre>
</div>

...or Python's fractions.gcd() (although the solution below is actually the Euclidean algorithm again, since that's a little more interesting).
<br/>
<a data-toggle="collapse" data-target="#gcd-python">
  <b>Python</b>
</a>
<div id="gcd-python" class="collapse">
<pre><code>import sys

gcd = int(sys.stdin.readline())
for a in map(int, sys.stdin):    
  while a:
    a, gcd = gcd % a, a
print gcd</code></pre>
</div>

<h1>Big Fibonacci</h1>

Python users are fortunate here in that their language has no limit on their integers.

<br/>
<a data-toggle="collapse" data-target="#fib-python">
  <b>Python</b>
</a>
<div id="fib-python" class="collapse">
<pre><code>import sys

def fibs():
    a, b = 1, 1
    while True:
        yield a
        a, b = b, a + b

d = int(sys.stdin.readline())
print next(n for n,f in enumerate(fibs(), 1) if d &lt;= len(str(f)))</code></pre>
</div>

Explicity calculating the Fibonacci numbers takes quadratic time. This is the expected solution to the problem.

<br/>
<a data-toggle="collapse" data-target="#fib-cpp">
  <b>C++</b>
</a>

<div id="fib-cpp" class="collapse">
<pre><code>#include &lt;iostream>
#include &lt;vector>

#define BASE 10
typedef int digit;

int main() {
    std::vector&lt;digit> a(1, 1);
    std::vector&lt;digit> b(1, 1);

    int n;
    size_t digits;
    for (n = 1, std::cin >> digits; a.size() &lt; digits; n++) {
        digit carry = 0;
        size_t i;
        for (i = 0; i &lt; a.size(); i++) {
            carry += a[i] + b[i];
            a[i] = carry % BASE;
            carry /= BASE;
        }
        for ( ; i &lt; b.size(); i++) {
            carry += b[i];
            a.push_back(carry % BASE);
            carry /= BASE;
        }
        if (carry) {
            a.push_back(carry);
        }
        a.swap(b);
    }

    std::cout &lt;&lt; n &lt;&lt; std::endl;
}
</code></pre>
</div>

FYI, the problem can actually be solve in <i>constant</i> time by applying the closed-form formula for nth Fibonacci number: <code>round(phi^n/sqrt(5))</code>

<br/>
<a data-toggle="collapse" data-target="#fib-java">
  <b>Java</b>
</a>

<div id="fib-java" class="collapse">
<pre><code>import static java.lang.Math.*;
import java.util.Scanner;

public class Main {
    private static final double PHI = (1 + sqrt(5)) / 2;

    public static void main(String[] args) {
        int d = new Scanner(System.in).nextInt();
        System.out.println(d == 1
            ? 1
            : (int)ceil(((d-1) * log(10) + log(sqrt(5))) / log(PHI))
        );
    }
}</code></pre>
</div>

<h1>Graph cycle detection</h1>

There are algorithms for doing this in O(E+V) time, but having at most 26 vertices pretty much tosses big-O concerns out the window. (The solutions below take O(E*V), O(V*V), and O(E*V) time, respectively.)

<br/>
<a data-toggle="collapse" data-target="#cycle-cpp">
  <b>C++</b>
</a>

<div id="cycle-cpp" class="collapse">
<pre><code>#include &lt;iostream>
#include &lt;set>
#include &lt;string>

using namespace std;

set&lt;int> graph[26];

bool canReach(int start, int end) {
    set&lt;int> tmp;
    tmp.swap(graph[start]);
    for (set&lt;int>::const_iterator it = tmp.begin(); it != tmp.end(); it++) {
        if (*it == end || canReach(*it, end)) {
            swap(tmp, graph[start]);
            return true;
        }
    }
    tmp.swap(graph[start]);
    return false;
}

int main() {
    for (string str; cin >> str; ) {
        graph[str[0]-'A'].insert(str[2]-'A');
    }
    for (int i = 0; i &lt; 26; i++) {
        if (canReach(i, i)) {
            cout &lt;&lt; (char)('A' + i);
        }
    }
    cout &lt;&lt; "\n";
}</code></pre>
</div>

<a data-toggle="collapse" data-target="#cycle-java">
  <b>Java</b>
</a>
<div id="cycle-java" class="collapse">
<pre><code>import java.util.*;

class Main {
    public static void main(String[] args) {
        boolean[][] adjacent = new boolean[26][26];
        for (Scanner in = new Scanner(System.in).useDelimiter("(?=\\w)")
                ; in.hasNext(); ) {
            adjacent[in.next().charAt(0)-'A'][in.next().charAt(0)-'A'] = true;
        }
        for (boolean changed = true; changed; ) {
            changed = false;
            for (int i = 0; i &lt; 26; i++) {
                for (int j = 0; j &lt; 26; j++) {
                    if (adjacent[i][j]) {
                        for (int k = 0; k &lt; 26; k++) {
                            if (adjacent[j][k] &amp;&amp; !adjacent[i][k]) {
                                adjacent[i][k] = true;
                                changed = true;
                            }
                        }
                    }
                }
            }
        }
        for (int i = 0; i &lt; 26; i++) {
            if (adjacent[i][i]) {
                System.out.print((char)('A' + i));
            }
        }
        System.out.println();
    }
}</code></pre>
</div>


<a data-toggle="collapse" data-target="#cycle-python">
  <b>Python</b>
</a>

<div id="cycle-python" class="collapse">
<pre><code>from collections import defaultdict
import sys

graph = defaultdict(set)
for a, b in map(lambda x: x.rstrip().split('-'), sys.stdin):
    graph[a].add(b)

def can_reach(start, end, visited):
    visited.add(start)
    return (
        end in graph[start]
        or any(can_reach(v, end, visited) for v in graph[start] - visited)
    )

print ''.join(sorted(v for v in graph if can_reach(v, v, set())))</code></pre>
</div>

<h1>Longest maze path</h1>

The longest path problem is NP-complete. Enumerating all paths and selecting the longest is sufficient. (Frankly, the most difficult part of this problem may be parsing the input.)

<br/>
<a data-toggle="collapse" data-target="#maze-python">
  <b>Python</b>
</a>

<div id="maze-python" class="collapse">
<pre><code>import re
import sys

graph = {}

re1 = re.compile(r'\((\d+,\d+)\),((?:\(\d+,\d+\))*)([es]?)')
re2 = re.compile(r'\((\d+,\d+)\)')
for line in sys.stdin:
    point, neighbors, flag = re1.match(line.rstrip()).groups()
    graph[point] = re2.findall(neighbors)
    if flag == 's':
        start = point
    elif flag == 'e':
        end = point

def longest(cur):
    neighbors, graph[cur] = graph[cur], ()
    try:
        return 1 if cur == end else 1 + max(longest(n) for n in neighbors)
    except ValueError:
        return 0
    finally:
        graph[cur] = neighbors

print longest(start)</code></pre>
</div>

<h1>Grid search</h1>

The are multiple correct ways to solve this problem. Remember to correctly count overlapping occurences of words. For example, <code>aaa</code> has 4 occurances of <code>aa</code> (recall that palindromes are double-counted).

<br/>
<a data-toggle="collapse" data-target="#grid-python">
  <b>Python</b>
</a>

<div id="grid-python" class="collapse">
<pre><code>import sys

keys = sys.stdin.readline().strip().split(',')

ps = [sys.stdin.readline().strip() for _ in xrange(50)] #horizontal
ps += map(''.join, (a for i in xrange(50) for a in (
        (p[i] for p in ps),                      #vertical
        (ps[i+j][j] for j in xrange(50-i)),      #diag1
        (ps[j][i+j] for j in xrange(50-i)),      #diag2
        (ps[i+j][50-1-j] for j in xrange(50-i)), #diag3
        (ps[50-1-j][i+j] for j in xrange(50-i)), #diag4
    ))
)
ps += [p[::-1] for p in ps]

print ','.join('{}:{}'.format(k, sum(p.count(k) for p in ps)) for k in keys)</code></pre>
</div>

<h1>Subwords</h1>

The key idea is to count the numbers of letters in the word, and compare those to the counts in the proposed subwords. The subword is valid iff the former counts are at least as great as the corresponding latter counts.

<br/>
<a data-toggle="collapse" data-target="#subwords-cpp">
  <b>C++</b>
</a>

<div id="subwords-cpp" class="collapse">
<pre><code>#include &lt;climits>
#include &lt;functional>
#include &lt;iostream>
#include &lt;numeric>
#include &lt;string>

using namespace std;;

int *charCounts(string const &amp;word) {
    int *counts = new int[UCHAR_MAX]();
    for (string::const_iterator it = word.begin(); it != word.end(); it++) {
        counts[(unsigned char)*it]++;
    }
    return counts;
}

int main() {
    int num, *counts;
    string word, subword;
    for (num = 0, cin >> word, counts = charCounts(word); cin >> subword; ) {
        num += (word != subword) &amp;&amp; inner_product(
            counts, counts+UCHAR_MAX, charCounts(subword)
            , true, logical_and&lt;bool>(), greater_equal&lt;int>()
        );
    }
    cout &lt;&lt; num &lt;&lt; "\n";
}</code></pre>
</div>

<a data-toggle="collapse" data-target="#subwords-java">
  <b>Java</b>
</a>
<div id="subwords-java" class="collapse">
<pre><code>import java.util.Scanner;

class Main {
    private static int[] counts(String ascii) {
        int[] counts = new int[256];
        for (char c : ascii.toCharArray()) {
            counts[c]++;
        }
        return counts;
    }

    private static boolean hasGTECounts(int[] a, int[] b) { // > or =
        for (int i = 0; i &lt; a.length; i++) {
            if (a[i] &lt; b[i]) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        int num = 0;
        Scanner in = new Scanner(System.in);
        String word = in.next();
        for (int[] counts = counts(word); in.hasNext(); ) {
            String sub = in.next();
            if (!word.equals(sub) &amp;&amp; hasGTECounts(counts, counts(sub))) {
                num++;
            }
        }
        System.out.println(num);
    }
}</code></pre>
</div>

<a data-toggle="collapse" data-target="#subwords-python">
  <b>Python</b>
</a>

<div id="subwords-python" class="collapse">
<pre><code>import sys
from collections import Counter

word = sys.stdin.readline().rstrip()
print sum(
    not Counter(subword.rstrip()) - Counter(word)
    for subword in sys.stdin if word != subword.rstrip()
)</code></pre>
</div>

      </div>
    </div>
    <script type="text/javascript" src="/js/vendor/jquery1.8.3.min.js"></script>
    <script type="text/javascript" src="/js/bootstrap.min.js"></script>
  </body>
</html>
